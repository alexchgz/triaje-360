{"version":3,"sources":["ng://ngx-ellipsis/lib/directives/ellipsis.directive.ts","ng://ngx-ellipsis/lib/ellipsis.module.ts"],"names":["EllipsisDirective","elementRef","renderer","ngZone","platformId","this","ellipsisContent","moreClickEmitter","EventEmitter","changeEmitter","numericBinarySearch","max","callback","mid","low","high","best","convertEllipsisInputToString","input","String","prototype","ngAfterViewInit","isPlatformBrowser","ellipsisCharacters","moreAnchor","createElement","className","href","textContent","ellipsisWordBoundaries","replace","ellipsisSubstrFn","str","from","length","substr","elem","nativeElement","originalText","trim","setProperty","innerElem","addClass","text","createText","appendChild","addResizeListener","ngOnChanges","applyEllipsis","ngOnDestroy","removeAllListeners","destroyMoreClickListener","removeResizeListener","triggerNow","resizeDetectionStrategy","addWindowResizeListener","addElementResizeListener","console","warn","_this","removeWindowResizeListener","listen","run","scrollStrategy","elementResizeDetector","elementResizeDetectorMaker","strategy","firstEvent","listenTo","getTruncatedText","truncatedText","charAt","match","i","truncateText","addMoreListener","truncatedLength","textTruncated","showMoreLink","e","target","preventDefault","emit","maxLength","curLength","isOverflowing","finalLength","observers","Object","defineProperty","currentOverflow","style","overflow","clientWidth","scrollWidth","clientHeight","scrollHeight","Directive","args","selector","exportAs","ElementRef","Renderer2","NgZone","decorators","type","Inject","PLATFORM_ID","Input","Output","EllipsisModule","NgModule","imports","declarations","exports"],"mappings":"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","sourcesContent":["import {\n  Directive,\n  ElementRef,\n  Renderer2,\n  Input,\n  Output,\n  EventEmitter,\n  NgZone,\n  OnChanges,\n  AfterViewInit,\n  OnDestroy,\n  Inject,\n  PLATFORM_ID\n} from '@angular/core';\nimport elementResizeDetectorMaker from 'element-resize-detector';\nimport { isPlatformBrowser } from '@angular/common';\n\n/**\n * Directive to truncate the contained text, if it exceeds the element's boundaries\n * and append characters (configurable, default '...') if so.\n */\n@Directive({\n  selector: '[ellipsis]',\n  exportAs: 'ellipsis'\n})\nexport class EllipsisDirective implements OnChanges, OnDestroy, AfterViewInit {\n  /**\n   * Instance of https://github.com/wnr/element-resize-detector\n   */\n  private static elementResizeDetector: elementResizeDetectorMaker.Erd = null;\n\n  /**\n   * The original text (not truncated yet)\n   */\n  private originalText: string;\n\n  /**\n   * The referenced element\n   */\n  private elem: any;\n\n  /**\n   * Inner div element (will be auto-created)\n   */\n  private innerElem: any;\n\n  /**\n   * Anchor tag wrapping the `ellipsisCharacters`\n   */\n  private moreAnchor: HTMLAnchorElement;\n\n  /**\n   * Remove function for the currently registered click listener\n   * on the link `this.ellipsisCharacters` are wrapped in.\n   */\n  private destroyMoreClickListener: () => void;\n\n  /**\n   * Remove the window listener registered by a previous call to `addWindowResizeListener()`.\n   */\n  private removeWindowResizeListener: () => void;\n\n  /**\n   * The ellipsis html attribute\n   * If anything is passed, this will be used as a string to append to\n   * the truncated contents.\n   * Else '...' will be appended.\n   */\n  @Input('ellipsis') ellipsisCharacters: string;\n\n  /**\n   * The ellipsis-content html attribute\n   * If passed this is used as content, else contents\n   * are fetched from textContent\n   */\n  @Input('ellipsis-content') ellipsisContent: string | number = null;\n\n  /**\n   * The ellipsis-word-boundaries html attribute\n   * If anything is passed, each character will be interpreted\n   * as a word boundary at which the text may be truncated.\n   * Else the text may be truncated at any character.\n   */\n  @Input('ellipsis-word-boundaries') ellipsisWordBoundaries: string;\n\n  /**\n   * Function to use for string splitting. Defaults to the native `String#substr`.\n   * (This may for example be used to avoid splitting surrogate pairs- used by some emojis -\n   * by providing a lib such as runes.)\n   */\n  @Input('ellipsis-substr-fn') ellipsisSubstrFn:  (str: string, from: number, length?: number) => string;\n\n  /**\n   * The ellipsis-resize-detection html attribute\n   * Algorithm to use to detect element/window resize - any of the following:\n   * 'element-resize-detector': (default) Use https://github.com/wnr/element-resize-detector with its 'scroll' strategy\n   * 'element-resize-detector-object': Use https://github.com/wnr/element-resize-detector with its 'object' strategy (deprecated)\n   * 'window': Only check if the whole window has been resized/changed orientation by using angular's built-in HostListener\n   */\n  @Input('ellipsis-resize-detection') resizeDetectionStrategy:\n    '' | 'manual' | 'element-resize-detector' | 'element-resize-detector-object' | 'window';\n\n  /**\n   * The ellipsis-click-more html attribute\n   * If anything is passed, the ellipsisCharacters will be\n   * wrapped in <a></a> tags and an event handler for the\n   * passed function will be added to the link\n   */\n  @Output('ellipsis-click-more') moreClickEmitter: EventEmitter<MouseEvent> = new EventEmitter();\n\n\n  /**\n   * The ellipsis-change html attribute\n   * This emits after which index the text has been truncated.\n   * If it hasn't been truncated, null is emitted.\n   */\n  @Output('ellipsis-change') changeEmitter: EventEmitter<number> = new EventEmitter();\n\n  /**\n   * Utility method to quickly find the largest number for\n   * which `callback(number)` still returns true.\n   * @param  max      Highest possible number\n   * @param  callback Should return true as long as the passed number is valid\n   * @return          Largest possible number\n   */\n  private static numericBinarySearch(max: number, callback: (n: number) => boolean): number {\n    let low = 0;\n    let high = max;\n    let best = -1;\n    let mid: number;\n\n    while (low <= high) {\n      // tslint:disable-next-line:no-bitwise\n      mid = ~~((low + high) / 2);\n      const result = callback(mid);\n      if (!result) {\n        high = mid - 1;\n      } else {\n        best = mid;\n        low = mid + 1;\n      }\n    }\n\n    return best;\n  }\n\n  /**\n   * Convert ellipsis input to string\n   * @param input string or number to be displayed as an ellipsis\n   * @return      input converted to string\n   */\n  private static convertEllipsisInputToString(input: string | number): string {\n    if (typeof input === 'undefined' || input === null) {\n      return '';\n    }\n\n    return String(input);\n  }\n\n  /**\n   * The directive's constructor\n   */\n  public constructor(\n    private elementRef: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private ngZone: NgZone,\n    @Inject(PLATFORM_ID) private platformId: Object\n  ) { }\n\n  /**\n   * Angular's init view life cycle hook.\n   * Initializes the element for displaying the ellipsis.\n   */\n  ngAfterViewInit() {\n    if (!isPlatformBrowser(this.platformId)) {\n      // in angular universal we don't have access to the ugly\n      // DOM manipulation properties we sadly need to access here,\n      // so wait until we're in the browser:\n      return;\n    }\n\n    // let the ellipsis characters default to '...':\n    if (this.ellipsisCharacters === '') {\n      this.ellipsisCharacters = '...';\n    }\n\n    // create more anchor element:\n    this.moreAnchor = <HTMLAnchorElement> this.renderer.createElement('a');\n    this.moreAnchor.className = 'ngx-ellipsis-more';\n    this.moreAnchor.href = '#';\n    this.moreAnchor.textContent = this.ellipsisCharacters;\n\n    // perform regex replace on word boundaries:\n    if (!this.ellipsisWordBoundaries) {\n      this.ellipsisWordBoundaries = '';\n    }\n    this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\\\n/, '\\n').replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') + ']';\n\n    if (!this.ellipsisSubstrFn) {\n      this.ellipsisSubstrFn = (str: string, from: number, length?: number) => {\n        return str.substr(from, length);\n      }\n    }\n\n    // store the original contents of the element:\n    this.elem = this.elementRef.nativeElement;\n    if (typeof this.ellipsisContent !== 'undefined' && this.ellipsisContent !== null) {\n      this.originalText = EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent);\n    } else if (!this.originalText) {\n      this.originalText = this.elem.textContent.trim();\n    }\n\n    // add a wrapper div (required for resize events to work properly):\n    this.renderer.setProperty(this.elem, 'innerHTML', '');\n    this.innerElem = this.renderer.createElement('div');\n    this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');\n    const text = this.renderer.createText(this.originalText);\n    this.renderer.appendChild(this.innerElem, text);\n    this.renderer.appendChild(this.elem, this.innerElem);\n\n    // start listening for resize events:\n    this.addResizeListener(true);\n  }\n\n  /**\n   * Angular's change life cycle hook.\n   * Change original text (if the ellipsis-content has been passed)\n   * and re-render\n   */\n  ngOnChanges() {\n    if (!this.elem\n      || typeof this.ellipsisContent === 'undefined'\n      || this.originalText === EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent)) {\n      return;\n    }\n\n    this.originalText = EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent);\n    this.applyEllipsis();\n  }\n\n  /**\n   * Angular's destroy life cycle hook.\n   * Remove event listeners\n   */\n  ngOnDestroy() {\n    // In angular universal we don't have any listeners hooked up (all requiring ugly DOM manipulation methods),\n    // so we only need to remove them, if we're inside the browser:\n    if (isPlatformBrowser(this.platformId)) {\n      this.removeAllListeners();\n    }\n  }\n\n  /**\n   * remove all resize listeners\n   */\n  private removeAllListeners() {\n    if (this.destroyMoreClickListener) {\n      this.destroyMoreClickListener();\n    }\n\n    this.removeResizeListener();\n  }\n\n\n  /**\n   * Set up an event listener to call applyEllipsis() whenever a resize has been registered.\n   * The type of the listener (window/element) depends on the resizeDetectionStrategy.\n   * @param triggerNow=false if true, the ellipsis is applied immediately\n   */\n  private addResizeListener(triggerNow = false) {\n    if (typeof (this.resizeDetectionStrategy) === 'undefined') {\n      this.resizeDetectionStrategy = '';\n    }\n\n    switch (this.resizeDetectionStrategy) {\n      case 'manual':\n        // Users will trigger applyEllipsis via the public API\n        break;\n      case 'window':\n        this.addWindowResizeListener();\n        break;\n      case 'element-resize-detector-object':\n        this.addElementResizeListener(false);\n        break;\n      default:\n        if (typeof (console) !== 'undefined') {\n          console.warn(\n            `No such ellipsis-resize-detection strategy: '${this.resizeDetectionStrategy}'. Using 'element-resize-detector' instead`\n          );\n        }\n      // eslint-disable-next-line no-fallthrough\n      case 'element-resize-detector':\n      case '':\n        this.addElementResizeListener();\n        break;\n    }\n\n    if (triggerNow && this.resizeDetectionStrategy !== 'manual') {\n      this.applyEllipsis();\n    }\n  }\n\n  /**\n   * Set up an event listener to call applyEllipsis() whenever the window gets resized.\n   */\n  private addWindowResizeListener() {\n    this.removeWindowResizeListener = this.renderer.listen('window', 'resize', () => {\n      this.ngZone.run(() => {\n        this.applyEllipsis();\n      });\n    });\n  }\n\n  /**\n   * Set up an event listener to call applyEllipsis() whenever the element\n   * has been resized.\n   * @param scrollStrategy=true Use the default elementResizeDetector's - strategy - s. https://github.com/wnr/element-resize-detector\n   */\n  private addElementResizeListener(scrollStrategy = true) {\n    if (!EllipsisDirective.elementResizeDetector) {\n      EllipsisDirective.elementResizeDetector = elementResizeDetectorMaker({ strategy: scrollStrategy ? 'scroll' : 'object' });\n    }\n\n\n    let firstEvent = true;\n    EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, () => {\n      if (firstEvent) {\n        // elementResizeDetector fires the event directly after re-attaching the listener\n        // -> discard that first event:\n        firstEvent = false;\n        return;\n      }\n      this.applyEllipsis();\n    });\n  }\n\n  /**\n   * Stop listening for any resize event.\n   */\n  private removeResizeListener() {\n    if (this.resizeDetectionStrategy !== 'window') {\n      if (EllipsisDirective.elementResizeDetector && this.elem) {\n        EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);\n      }\n    } else {\n      this.removeWindowResizeListener();\n    }\n  }\n\n  /**\n   * Get the original text's truncated version. If the text really needed to\n   * be truncated, this.ellipsisCharacters will be appended.\n   * @param max the maximum length the text may have\n   * @return string       the truncated string\n   */\n  private getTruncatedText(max: number): string {\n    if (!this.originalText || this.originalText.length <= max) {\n      return this.originalText;\n    }\n\n    const truncatedText = this.ellipsisSubstrFn(this.originalText, 0, max);\n    if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {\n      return truncatedText;\n    }\n\n    let i = max - 1;\n    while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {\n      i--;\n    }\n    return this.ellipsisSubstrFn(truncatedText, 0, i);\n  }\n\n  /**\n   * Set the truncated text to be displayed in the inner div\n   * @param max the maximum length the text may have\n   * @param addMoreListener=false listen for click on the ellipsisCharacters anchor tag if the text has been truncated\n   * @returns length of remaining text (excluding the ellipsisCharacters, if they were added)\n   */\n  private truncateText(max: number, addMoreListener = false): number {\n    let text = this.getTruncatedText(max);\n    const truncatedLength = text.length;\n    const textTruncated = (truncatedLength !== this.originalText.length);\n\n    if (textTruncated && !this.showMoreLink) {\n      text += this.ellipsisCharacters;\n    }\n\n    this.renderer.setProperty(this.innerElem, 'textContent', text);\n\n    if (textTruncated && this.showMoreLink) {\n      this.renderer.appendChild(this.innerElem, this.moreAnchor);\n    }\n\n    // Remove any existing more click listener:\n    if (this.destroyMoreClickListener) {\n      this.destroyMoreClickListener();\n      this.destroyMoreClickListener = null;\n    }\n\n    // If the text has been truncated, add a more click listener:\n    if (addMoreListener && textTruncated) {\n      this.destroyMoreClickListener = this.renderer.listen(this.moreAnchor, 'click', (e: MouseEvent) => {\n        if (!e.target || (<HTMLElement> e.target).className !== 'ngx-ellipsis-more') {\n          return;\n        }\n        e.preventDefault();\n        this.moreClickEmitter.emit(e);\n      });\n    }\n\n    return truncatedLength;\n  }\n\n  /**\n   * Display ellipsis in the inner div if the text would exceed the boundaries\n   */\n  public applyEllipsis() {\n    // Remove the resize listener as changing the contained text would trigger events:\n    this.removeResizeListener();\n\n    // Find the best length by trial and error:\n    const maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, curLength => {\n      this.truncateText(curLength);\n      return !this.isOverflowing;\n    });\n\n    // Apply the best length:\n    const finalLength = this.truncateText(maxLength, this.showMoreLink);\n\n    // Re-attach the resize listener:\n    this.addResizeListener();\n\n    // Emit change event:\n    if (this.changeEmitter.observers.length > 0) {\n      this.changeEmitter.emit(\n        (this.originalText.length === finalLength) ? null : finalLength\n      );\n    }\n  }\n\n\n  /**\n   * Whether the text is exceeding the element's boundaries or not\n   */\n  private get isOverflowing(): boolean {\n    // Enforce hidden overflow (required to compare client width/height with scroll width/height)\n    const currentOverflow = this.elem.style.overflow;\n    if (!currentOverflow || currentOverflow === 'visible') {\n      this.elem.style.overflow = 'hidden';\n    }\n\n    const isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;\n\n    // Reset overflow to the original configuration:\n    this.elem.style.overflow = currentOverflow;\n\n    return isOverflowing;\n  }\n\n  /**\n   * Whether the `ellipsisCharacters` are to be wrapped inside an anchor tag (if they are shown at all)\n   */\n  private get showMoreLink(): boolean {\n    return (this.moreClickEmitter.observers.length > 0);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { EllipsisDirective } from './directives/ellipsis.directive';\n\n@NgModule({\n  imports: [\n  ],\n  declarations: [EllipsisDirective],\n  exports: [EllipsisDirective]\n})\nexport class EllipsisModule { }\n"]}