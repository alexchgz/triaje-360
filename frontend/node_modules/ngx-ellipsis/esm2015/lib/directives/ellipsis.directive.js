/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/ellipsis.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, Inject, PLATFORM_ID } from '@angular/core';
import elementResizeDetectorMaker from 'element-resize-detector';
import { isPlatformBrowser } from '@angular/common';
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
export class EllipsisDirective {
    /**
     * The directive's constructor
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} ngZone
     * @param {?} platformId
     */
    constructor(elementRef, renderer, ngZone, platformId) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.platformId = platformId;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from textContent
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         * If anything is passed, the ellipsisCharacters will be
         * wrapped in <a></a> tags and an event handler for the
         * passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
        /**
         * The ellipsis-change html attribute
         * This emits after which index the text has been truncated.
         * If it hasn't been truncated, null is emitted.
         */
        this.changeEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @private
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    static numericBinarySearch(max, callback) {
        /** @type {?} */
        let low = 0;
        /** @type {?} */
        let high = max;
        /** @type {?} */
        let best = -1;
        /** @type {?} */
        let mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            /** @type {?} */
            const result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    }
    /**
     * Convert ellipsis input to string
     * @private
     * @param {?} input string or number to be displayed as an ellipsis
     * @return {?} input converted to string
     */
    static convertEllipsisInputToString(input) {
        if (typeof input === 'undefined' || input === null) {
            return '';
        }
        return String(input);
    }
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    ngAfterViewInit() {
        if (!isPlatformBrowser(this.platformId)) {
            // in angular universal we don't have access to the ugly
            // DOM manipulation properties we sadly need to access here,
            // so wait until we're in the browser:
            return;
        }
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        // create more anchor element:
        this.moreAnchor = (/** @type {?} */ (this.renderer.createElement('a')));
        this.moreAnchor.className = 'ngx-ellipsis-more';
        this.moreAnchor.href = '#';
        this.moreAnchor.textContent = this.ellipsisCharacters;
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        if (!this.ellipsisSubstrFn) {
            this.ellipsisSubstrFn = (/**
             * @param {?} str
             * @param {?} from
             * @param {?=} length
             * @return {?}
             */
            (str, from, length) => {
                return str.substr(from, length);
            });
        }
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (typeof this.ellipsisContent !== 'undefined' && this.ellipsisContent !== null) {
            this.originalText = EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent);
        }
        else if (!this.originalText) {
            this.originalText = this.elem.textContent.trim();
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        /** @type {?} */
        const text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    }
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    ngOnChanges() {
        if (!this.elem
            || typeof this.ellipsisContent === 'undefined'
            || this.originalText === EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent)) {
            return;
        }
        this.originalText = EllipsisDirective.convertEllipsisInputToString(this.ellipsisContent);
        this.applyEllipsis();
    }
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    ngOnDestroy() {
        // In angular universal we don't have any listeners hooked up (all requiring ugly DOM manipulation methods),
        // so we only need to remove them, if we're inside the browser:
        if (isPlatformBrowser(this.platformId)) {
            this.removeAllListeners();
        }
    }
    /**
     * remove all resize listeners
     * @private
     * @return {?}
     */
    removeAllListeners() {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @private
     * @param {?=} triggerNow
     * @return {?}
     */
    addResizeListener(triggerNow = false) {
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'manual':
                // Users will trigger applyEllipsis via the public API
                break;
            case 'window':
                this.addWindowResizeListener();
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn(`No such ellipsis-resize-detection strategy: '${this.resizeDetectionStrategy}'. Using 'element-resize-detector' instead`);
                }
            // eslint-disable-next-line no-fallthrough
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
        if (triggerNow && this.resizeDetectionStrategy !== 'manual') {
            this.applyEllipsis();
        }
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the window gets resized.
     * @private
     * @return {?}
     */
    addWindowResizeListener() {
        this.removeWindowResizeListener = this.renderer.listen('window', 'resize', (/**
         * @return {?}
         */
        () => {
            this.ngZone.run((/**
             * @return {?}
             */
            () => {
                this.applyEllipsis();
            }));
        }));
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @private
     * @param {?=} scrollStrategy
     * @return {?}
     */
    addElementResizeListener(scrollStrategy = true) {
        if (!EllipsisDirective.elementResizeDetector) {
            EllipsisDirective.elementResizeDetector = elementResizeDetectorMaker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        /** @type {?} */
        let firstEvent = true;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, (/**
         * @return {?}
         */
        () => {
            if (firstEvent) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                firstEvent = false;
                return;
            }
            this.applyEllipsis();
        }));
    }
    /**
     * Stop listening for any resize event.
     * @private
     * @return {?}
     */
    removeResizeListener() {
        if (this.resizeDetectionStrategy !== 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.removeWindowResizeListener();
        }
    }
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @private
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    getTruncatedText(max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        /** @type {?} */
        const truncatedText = this.ellipsisSubstrFn(this.originalText, 0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText;
        }
        /** @type {?} */
        let i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return this.ellipsisSubstrFn(truncatedText, 0, i);
    }
    /**
     * Set the truncated text to be displayed in the inner div
     * @private
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?} length of remaining text (excluding the ellipsisCharacters, if they were added)
     */
    truncateText(max, addMoreListener = false) {
        /** @type {?} */
        let text = this.getTruncatedText(max);
        /** @type {?} */
        const truncatedLength = text.length;
        /** @type {?} */
        const textTruncated = (truncatedLength !== this.originalText.length);
        if (textTruncated && !this.showMoreLink) {
            text += this.ellipsisCharacters;
        }
        this.renderer.setProperty(this.innerElem, 'textContent', text);
        if (textTruncated && this.showMoreLink) {
            this.renderer.appendChild(this.innerElem, this.moreAnchor);
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
            this.destroyMoreClickListener = null;
        }
        // If the text has been truncated, add a more click listener:
        if (addMoreListener && textTruncated) {
            this.destroyMoreClickListener = this.renderer.listen(this.moreAnchor, 'click', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                if (!e.target || ((/** @type {?} */ (e.target))).className !== 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                this.moreClickEmitter.emit(e);
            }));
        }
        return truncatedLength;
    }
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    applyEllipsis() {
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        // Find the best length by trial and error:
        /** @type {?} */
        const maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, (/**
         * @param {?} curLength
         * @return {?}
         */
        curLength => {
            this.truncateText(curLength);
            return !this.isOverflowing;
        }));
        // Apply the best length:
        /** @type {?} */
        const finalLength = this.truncateText(maxLength, this.showMoreLink);
        // Re-attach the resize listener:
        this.addResizeListener();
        // Emit change event:
        if (this.changeEmitter.observers.length > 0) {
            this.changeEmitter.emit((this.originalText.length === finalLength) ? null : finalLength);
        }
    }
    /**
     * Whether the text is exceeding the element's boundaries or not
     * @private
     * @return {?}
     */
    get isOverflowing() {
        // Enforce hidden overflow (required to compare client width/height with scroll width/height)
        /** @type {?} */
        const currentOverflow = this.elem.style.overflow;
        if (!currentOverflow || currentOverflow === 'visible') {
            this.elem.style.overflow = 'hidden';
        }
        /** @type {?} */
        const isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
        // Reset overflow to the original configuration:
        this.elem.style.overflow = currentOverflow;
        return isOverflowing;
    }
    /**
     * Whether the `ellipsisCharacters` are to be wrapped inside an anchor tag (if they are shown at all)
     * @private
     * @return {?}
     */
    get showMoreLink() {
        return (this.moreClickEmitter.observers.length > 0);
    }
}
/**
 * Instance of https://github.com/wnr/element-resize-detector
 */
EllipsisDirective.elementResizeDetector = null;
EllipsisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ellipsis]',
                exportAs: 'ellipsis'
            },] }
];
/** @nocollapse */
EllipsisDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
EllipsisDirective.propDecorators = {
    ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
    ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
    ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
    ellipsisSubstrFn: [{ type: Input, args: ['ellipsis-substr-fn',] }],
    resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
    moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
    changeEmitter: [{ type: Output, args: ['ellipsis-change',] }]
};
if (false) {
    /**
     * Instance of https://github.com/wnr/element-resize-detector
     * @type {?}
     * @private
     */
    EllipsisDirective.elementResizeDetector;
    /**
     * The original text (not truncated yet)
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.originalText;
    /**
     * The referenced element
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.elem;
    /**
     * Inner div element (will be auto-created)
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.innerElem;
    /**
     * Anchor tag wrapping the `ellipsisCharacters`
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.moreAnchor;
    /**
     * Remove function for the currently registered click listener
     * on the link `this.ellipsisCharacters` are wrapped in.
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.destroyMoreClickListener;
    /**
     * Remove the window listener registered by a previous call to `addWindowResizeListener()`.
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.removeWindowResizeListener;
    /**
     * The ellipsis html attribute
     * If anything is passed, this will be used as a string to append to
     * the truncated contents.
     * Else '...' will be appended.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisCharacters;
    /**
     * The ellipsis-content html attribute
     * If passed this is used as content, else contents
     * are fetched from textContent
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisContent;
    /**
     * The ellipsis-word-boundaries html attribute
     * If anything is passed, each character will be interpreted
     * as a word boundary at which the text may be truncated.
     * Else the text may be truncated at any character.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisWordBoundaries;
    /**
     * Function to use for string splitting. Defaults to the native `String#substr`.
     * (This may for example be used to avoid splitting surrogate pairs- used by some emojis -
     * by providing a lib such as runes.)
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisSubstrFn;
    /**
     * The ellipsis-resize-detection html attribute
     * Algorithm to use to detect element/window resize - any of the following:
     * 'element-resize-detector': (default) Use https://github.com/wnr/element-resize-detector with its 'scroll' strategy
     * 'element-resize-detector-object': Use https://github.com/wnr/element-resize-detector with its 'object' strategy (deprecated)
     * 'window': Only check if the whole window has been resized/changed orientation by using angular's built-in HostListener
     * @type {?}
     */
    EllipsisDirective.prototype.resizeDetectionStrategy;
    /**
     * The ellipsis-click-more html attribute
     * If anything is passed, the ellipsisCharacters will be
     * wrapped in <a></a> tags and an event handler for the
     * passed function will be added to the link
     * @type {?}
     */
    EllipsisDirective.prototype.moreClickEmitter;
    /**
     * The ellipsis-change html attribute
     * This emits after which index the text has been truncated.
     * If it hasn't been truncated, null is emitted.
     * @type {?}
     */
    EllipsisDirective.prototype.changeEmitter;
    /**
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.ngZone;
    /**
     * @type {?}
     * @private
     */
    EllipsisDirective.prototype.platformId;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxsaXBzaXMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWVsbGlwc2lzLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLE1BQU0sRUFJTixNQUFNLEVBQ04sV0FBVyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sMEJBQTBCLE1BQU0seUJBQXlCLENBQUM7QUFDakUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7O0FBVXBELE1BQU0sT0FBTyxpQkFBaUI7Ozs7Ozs7O0lBeUk1QixZQUNVLFVBQW1DLEVBQ25DLFFBQW1CLEVBQ25CLE1BQWMsRUFDTyxVQUFrQjtRQUh2QyxlQUFVLEdBQVYsVUFBVSxDQUF5QjtRQUNuQyxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDTyxlQUFVLEdBQVYsVUFBVSxDQUFROzs7Ozs7UUEzRnRCLG9CQUFlLEdBQW9CLElBQUksQ0FBQzs7Ozs7OztRQWlDcEMscUJBQWdCLEdBQTZCLElBQUksWUFBWSxFQUFFLENBQUM7Ozs7OztRQVFwRSxrQkFBYSxHQUF5QixJQUFJLFlBQVksRUFBRSxDQUFDO0lBbURoRixDQUFDOzs7Ozs7Ozs7SUExQ0csTUFBTSxDQUFDLG1CQUFtQixDQUFDLEdBQVcsRUFBRSxRQUFnQzs7WUFDMUUsR0FBRyxHQUFHLENBQUM7O1lBQ1AsSUFBSSxHQUFHLEdBQUc7O1lBQ1YsSUFBSSxHQUFHLENBQUMsQ0FBQzs7WUFDVCxHQUFXO1FBRWYsT0FBTyxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ2xCLHNDQUFzQztZQUN0QyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdB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O1lBdEJDLFVBQVU7WUFDVixTQUFTO1lBSVQsTUFBTTtZQStKcUMsTUFBTSx1QkFBOUMsTUFBTSxTQUFDLFdBQVc7OztpQ0FsR3BCLEtBQUssU0FBQyxVQUFVOzhCQU9oQixLQUFLLFNBQUMsa0JBQWtCO3FDQVF4QixLQUFLLFNBQUMsMEJBQTBCOytCQU9oQyxLQUFLLFNBQUMsb0JBQW9CO3NDQVMxQixLQUFLLFNBQUMsMkJBQTJCOytCQVNqQyxNQUFNLFNBQUMscUJBQXFCOzRCQVE1QixNQUFNLFNBQUMsaUJBQWlCOzs7Ozs7OztJQXZGekIsd0NBQTRFOzs7Ozs7SUFLNUUseUNBQTZCOzs7Ozs7SUFLN0IsaUNBQWtCOzs7Ozs7SUFLbEIsc0NBQXVCOzs7Ozs7SUFLdkIsdUNBQXNDOzs7Ozs7O0lBTXRDLHFEQUE2Qzs7Ozs7O0lBSzdDLHVEQUErQzs7Ozs7Ozs7SUFRL0MsK0NBQThDOzs7Ozs7O0lBTzlDLDRDQUFtRTs7Ozs7Ozs7SUFRbkUsbURBQWtFOzs7Ozs7O0lBT2xFLDZDQUF1Rzs7Ozs7Ozs7O0lBU3ZHLG9EQUMwRjs7Ozs7Ozs7SUFRMUYsNkNBQStGOzs7Ozs7O0lBUS9GLDBDQUFvRjs7Ozs7SUErQ2xGLHVDQUEyQzs7Ozs7SUFDM0MscUNBQTJCOzs7OztJQUMzQixtQ0FBc0I7Ozs7O0lBQ3RCLHVDQUErQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgUmVuZGVyZXIyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIE5nWm9uZSxcbiAgT25DaGFuZ2VzLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3ksXG4gIEluamVjdCxcbiAgUExBVEZPUk1fSURcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIgZnJvbSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIERpcmVjdGl2ZSB0byB0cnVuY2F0ZSB0aGUgY29udGFpbmVkIHRleHQsIGlmIGl0IGV4Y2VlZHMgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzXG4gKiBhbmQgYXBwZW5kIGNoYXJhY3RlcnMgKGNvbmZpZ3VyYWJsZSwgZGVmYXVsdCAnLi4uJykgaWYgc28uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlbGxpcHNpc10nLFxuICBleHBvcnRBczogJ2VsbGlwc2lzJ1xufSlcbmV4cG9ydCBjbGFzcyBFbGxpcHNpc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95LCBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIEluc3RhbmNlIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3JcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGVsZW1lbnRSZXNpemVEZXRlY3RvcjogZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIuRXJkID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIG9yaWdpbmFsIHRleHQgKG5vdCB0cnVuY2F0ZWQgeWV0KVxuICAgKi9cbiAgcHJpdmF0ZSBvcmlnaW5hbFRleHQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlZmVyZW5jZWQgZWxlbWVudFxuICAgKi9cbiAgcHJpdmF0ZSBlbGVtOiBhbnk7XG5cbiAgLyoqXG4gICAqIElubmVyIGRpdiBlbGVtZW50ICh3aWxsIGJlIGF1dG8tY3JlYXRlZClcbiAgICovXG4gIHByaXZhdGUgaW5uZXJFbGVtOiBhbnk7XG5cbiAgLyoqXG4gICAqIEFuY2hvciB0YWcgd3JhcHBpbmcgdGhlIGBlbGxpcHNpc0NoYXJhY3RlcnNgXG4gICAqL1xuICBwcml2YXRlIG1vcmVBbmNob3I6IEhUTUxBbmNob3JFbGVtZW50O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBjbGljayBsaXN0ZW5lclxuICAgKiBvbiB0aGUgbGluayBgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnNgIGFyZSB3cmFwcGVkIGluLlxuICAgKi9cbiAgcHJpdmF0ZSBkZXN0cm95TW9yZUNsaWNrTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgd2luZG93IGxpc3RlbmVyIHJlZ2lzdGVyZWQgYnkgYSBwcmV2aW91cyBjYWxsIHRvIGBhZGRXaW5kb3dSZXNpemVMaXN0ZW5lcigpYC5cbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlV2luZG93UmVzaXplTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcyBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIHRoaXMgd2lsbCBiZSB1c2VkIGFzIGEgc3RyaW5nIHRvIGFwcGVuZCB0b1xuICAgKiB0aGUgdHJ1bmNhdGVkIGNvbnRlbnRzLlxuICAgKiBFbHNlICcuLi4nIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzJykgZWxsaXBzaXNDaGFyYWN0ZXJzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1jb250ZW50IGh0bWwgYXR0cmlidXRlXG4gICAqIElmIHBhc3NlZCB0aGlzIGlzIHVzZWQgYXMgY29udGVudCwgZWxzZSBjb250ZW50c1xuICAgKiBhcmUgZmV0Y2hlZCBmcm9tIHRleHRDb250ZW50XG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLWNvbnRlbnQnKSBlbGxpcHNpc0NvbnRlbnQ6IHN0cmluZyB8IG51bWJlciA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCBlYWNoIGNoYXJhY3RlciB3aWxsIGJlIGludGVycHJldGVkXG4gICAqIGFzIGEgd29yZCBib3VuZGFyeSBhdCB3aGljaCB0aGUgdGV4dCBtYXkgYmUgdHJ1bmNhdGVkLlxuICAgKiBFbHNlIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQgYXQgYW55IGNoYXJhY3Rlci5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtd29yZC1ib3VuZGFyaWVzJykgZWxsaXBzaXNXb3JkQm91bmRhcmllczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byB1c2UgZm9yIHN0cmluZyBzcGxpdHRpbmcuIERlZmF1bHRzIHRvIHRoZSBuYXRpdmUgYFN0cmluZyNzdWJzdHJgLlxuICAgKiAoVGhpcyBtYXkgZm9yIGV4YW1wbGUgYmUgdXNlZCB0byBhdm9pZCBzcGxpdHRpbmcgc3Vycm9nYXRlIHBhaXJzLSB1c2VkIGJ5IHNvbWUgZW1vamlzIC1cbiAgICogYnkgcHJvdmlkaW5nIGEgbGliIHN1Y2ggYXMgcnVuZXMuKVxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy1zdWJzdHItZm4nKSBlbGxpcHNpc1N1YnN0ckZuOiAgKHN0cjogc3RyaW5nLCBmcm9tOiBudW1iZXIsIGxlbmd0aD86IG51bWJlcikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtcmVzaXplLWRldGVjdGlvbiBodG1sIGF0dHJpYnV0ZVxuICAgKiBBbGdvcml0aG0gdG8gdXNlIHRvIGRldGVjdCBlbGVtZW50L3dpbmRvdyByZXNpemUgLSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzogKGRlZmF1bHQpIFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdzY3JvbGwnIHN0cmF0ZWd5XG4gICAqICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnOiBVc2UgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvciB3aXRoIGl0cyAnb2JqZWN0JyBzdHJhdGVneSAoZGVwcmVjYXRlZClcbiAgICogJ3dpbmRvdyc6IE9ubHkgY2hlY2sgaWYgdGhlIHdob2xlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkL2NoYW5nZWQgb3JpZW50YXRpb24gYnkgdXNpbmcgYW5ndWxhcidzIGJ1aWx0LWluIEhvc3RMaXN0ZW5lclxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uJykgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3k6XG4gICAgJycgfCAnbWFudWFsJyB8ICdlbGVtZW50LXJlc2l6ZS1kZXRlY3RvcicgfCAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Itb2JqZWN0JyB8ICd3aW5kb3cnO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtY2xpY2stbW9yZSBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIHRoZSBlbGxpcHNpc0NoYXJhY3RlcnMgd2lsbCBiZVxuICAgKiB3cmFwcGVkIGluIDxhPjwvYT4gdGFncyBhbmQgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlXG4gICAqIHBhc3NlZCBmdW5jdGlvbiB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsaW5rXG4gICAqL1xuICBAT3V0cHV0KCdlbGxpcHNpcy1jbGljay1tb3JlJykgbW9yZUNsaWNrRW1pdHRlcjogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1jaGFuZ2UgaHRtbCBhdHRyaWJ1dGVcbiAgICogVGhpcyBlbWl0cyBhZnRlciB3aGljaCBpbmRleCB0aGUgdGV4dCBoYXMgYmVlbiB0cnVuY2F0ZWQuXG4gICAqIElmIGl0IGhhc24ndCBiZWVuIHRydW5jYXRlZCwgbnVsbCBpcyBlbWl0dGVkLlxuICAgKi9cbiAgQE91dHB1dCgnZWxsaXBzaXMtY2hhbmdlJykgY2hhbmdlRW1pdHRlcjogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHRvIHF1aWNrbHkgZmluZCB0aGUgbGFyZ2VzdCBudW1iZXIgZm9yXG4gICAqIHdoaWNoIGBjYWxsYmFjayhudW1iZXIpYCBzdGlsbCByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSAgbWF4ICAgICAgSGlnaGVzdCBwb3NzaWJsZSBudW1iZXJcbiAgICogQHBhcmFtICBjYWxsYmFjayBTaG91bGQgcmV0dXJuIHRydWUgYXMgbG9uZyBhcyB0aGUgcGFzc2VkIG51bWJlciBpcyB2YWxpZFxuICAgKiBAcmV0dXJuICAgICAgICAgIExhcmdlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBudW1lcmljQmluYXJ5U2VhcmNoKG1heDogbnVtYmVyLCBjYWxsYmFjazogKG46IG51bWJlcikgPT4gYm9vbGVhbik6IG51bWJlciB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBtYXg7XG4gICAgbGV0IGJlc3QgPSAtMTtcbiAgICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICBtaWQgPSB+figobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKG1pZCk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlc3QgPSBtaWQ7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBlbGxpcHNpcyBpbnB1dCB0byBzdHJpbmdcbiAgICogQHBhcmFtIGlucHV0IHN0cmluZyBvciBudW1iZXIgdG8gYmUgZGlzcGxheWVkIGFzIGFuIGVsbGlwc2lzXG4gICAqIEByZXR1cm4gICAgICBpbnB1dCBjb252ZXJ0ZWQgdG8gc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjb252ZXJ0RWxsaXBzaXNJbnB1dFRvU3RyaW5nKGlucHV0OiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdFxuICApIHsgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgaW5pdCB2aWV3IGxpZmUgY3ljbGUgaG9vay5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGVsZW1lbnQgZm9yIGRpc3BsYXlpbmcgdGhlIGVsbGlwc2lzLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgLy8gaW4gYW5ndWxhciB1bml2ZXJzYWwgd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIHVnbHlcbiAgICAgIC8vIERPTSBtYW5pcHVsYXRpb24gcHJvcGVydGllcyB3ZSBzYWRseSBuZWVkIHRvIGFjY2VzcyBoZXJlLFxuICAgICAgLy8gc28gd2FpdCB1bnRpbCB3ZSdyZSBpbiB0aGUgYnJvd3NlcjpcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBsZXQgdGhlIGVsbGlwc2lzIGNoYXJhY3RlcnMgZGVmYXVsdCB0byAnLi4uJzpcbiAgICBpZiAodGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPT09ICcnKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9ICcuLi4nO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBtb3JlIGFuY2hvciBlbGVtZW50OlxuICAgIHRoaXMubW9yZUFuY2hvciA9IDxIVE1MQW5jaG9yRWxlbWVudD4gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdGhpcy5tb3JlQW5jaG9yLmNsYXNzTmFtZSA9ICduZ3gtZWxsaXBzaXMtbW9yZSc7XG4gICAgdGhpcy5tb3JlQW5jaG9yLmhyZWYgPSAnIyc7XG4gICAgdGhpcy5tb3JlQW5jaG9yLnRleHRDb250ZW50ID0gdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG5cbiAgICAvLyBwZXJmb3JtIHJlZ2V4IHJlcGxhY2Ugb24gd29yZCBib3VuZGFyaWVzOlxuICAgIGlmICghdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPSAnJztcbiAgICB9XG4gICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJ1snICsgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpICsgJ10nO1xuXG4gICAgaWYgKCF0aGlzLmVsbGlwc2lzU3Vic3RyRm4pIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNTdWJzdHJGbiA9IChzdHI6IHN0cmluZywgZnJvbTogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoZnJvbSwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0aGUgb3JpZ2luYWwgY29udGVudHMgb2YgdGhlIGVsZW1lbnQ6XG4gICAgdGhpcy5lbGVtID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsbGlwc2lzQ29udGVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5lbGxpcHNpc0NvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gRWxsaXBzaXNEaXJlY3RpdmUuY29udmVydEVsbGlwc2lzSW5wdXRUb1N0cmluZyh0aGlzLmVsbGlwc2lzQ29udGVudCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5vcmlnaW5hbFRleHQpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gdGhpcy5lbGVtLnRleHRDb250ZW50LnRyaW0oKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSB3cmFwcGVyIGRpdiAocmVxdWlyZWQgZm9yIHJlc2l6ZSBldmVudHMgdG8gd29yayBwcm9wZXJseSk6XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW0sICdpbm5lckhUTUwnLCAnJyk7XG4gICAgdGhpcy5pbm5lckVsZW0gPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5pbm5lckVsZW0sICduZ3gtZWxsaXBzaXMtaW5uZXInKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVUZXh0KHRoaXMub3JpZ2luYWxUZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJFbGVtLCB0ZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbSwgdGhpcy5pbm5lckVsZW0pO1xuXG4gICAgLy8gc3RhcnQgbGlzdGVuaW5nIGZvciByZXNpemUgZXZlbnRzOlxuICAgIHRoaXMuYWRkUmVzaXplTGlzdGVuZXIodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGNoYW5nZSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIENoYW5nZSBvcmlnaW5hbCB0ZXh0IChpZiB0aGUgZWxsaXBzaXMtY29udGVudCBoYXMgYmVlbiBwYXNzZWQpXG4gICAqIGFuZCByZS1yZW5kZXJcbiAgICovXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIGlmICghdGhpcy5lbGVtXG4gICAgICB8fCB0eXBlb2YgdGhpcy5lbGxpcHNpc0NvbnRlbnQgPT09ICd1bmRlZmluZWQnXG4gICAgICB8fCB0aGlzLm9yaWdpbmFsVGV4dCA9PT0gRWxsaXBzaXNEaXJlY3RpdmUuY29udmVydEVsbGlwc2lzSW5wdXRUb1N0cmluZyh0aGlzLmVsbGlwc2lzQ29udGVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsVGV4dCA9IEVsbGlwc2lzRGlyZWN0aXZlLmNvbnZlcnRFbGxpcHNpc0lucHV0VG9TdHJpbmcodGhpcy5lbGxpcHNpc0NvbnRlbnQpO1xuICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuZ3VsYXIncyBkZXN0cm95IGxpZmUgY3ljbGUgaG9vay5cbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgLy8gSW4gYW5ndWxhciB1bml2ZXJzYWwgd2UgZG9uJ3QgaGF2ZSBhbnkgbGlzdGVuZXJzIGhvb2tlZCB1cCAoYWxsIHJlcXVpcmluZyB1Z2x5IERPTSBtYW5pcHVsYXRpb24gbWV0aG9kcyksXG4gICAgLy8gc28gd2Ugb25seSBuZWVkIHRvIHJlbW92ZSB0aGVtLCBpZiB3ZSdyZSBpbnNpZGUgdGhlIGJyb3dzZXI6XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBhbGwgcmVzaXplIGxpc3RlbmVyc1xuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlUmVzaXplTGlzdGVuZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBjYWxsIGFwcGx5RWxsaXBzaXMoKSB3aGVuZXZlciBhIHJlc2l6ZSBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXIgKHdpbmRvdy9lbGVtZW50KSBkZXBlbmRzIG9uIHRoZSByZXNpemVEZXRlY3Rpb25TdHJhdGVneS5cbiAgICogQHBhcmFtIHRyaWdnZXJOb3c9ZmFsc2UgaWYgdHJ1ZSwgdGhlIGVsbGlwc2lzIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHlcbiAgICovXG4gIHByaXZhdGUgYWRkUmVzaXplTGlzdGVuZXIodHJpZ2dlck5vdyA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ID0gJyc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgICBjYXNlICdtYW51YWwnOlxuICAgICAgICAvLyBVc2VycyB3aWxsIHRyaWdnZXIgYXBwbHlFbGxpcHNpcyB2aWEgdGhlIHB1YmxpYyBBUElcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICB0aGlzLmFkZFdpbmRvd1Jlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Itb2JqZWN0JzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnNvbGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBObyBzdWNoIGVsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24gc3RyYXRlZ3k6ICcke3RoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3l9Jy4gVXNpbmcgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJyBpbnN0ZWFkYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgY2FzZSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOlxuICAgICAgY2FzZSAnJzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRyaWdnZXJOb3cgJiYgdGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgdGhlIHdpbmRvdyBnZXRzIHJlc2l6ZWQuXG4gICAqL1xuICBwcml2YXRlIGFkZFdpbmRvd1Jlc2l6ZUxpc3RlbmVyKCkge1xuICAgIHRoaXMucmVtb3ZlV2luZG93UmVzaXplTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbignd2luZG93JywgJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGNhbGwgYXBwbHlFbGxpcHNpcygpIHdoZW5ldmVyIHRoZSBlbGVtZW50XG4gICAqIGhhcyBiZWVuIHJlc2l6ZWQuXG4gICAqIEBwYXJhbSBzY3JvbGxTdHJhdGVneT10cnVlIFVzZSB0aGUgZGVmYXVsdCBlbGVtZW50UmVzaXplRGV0ZWN0b3IncyAtIHN0cmF0ZWd5IC0gcy4gaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBhZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoc2Nyb2xsU3RyYXRlZ3kgPSB0cnVlKSB7XG4gICAgaWYgKCFFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IpIHtcbiAgICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciA9IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyKHsgc3RyYXRlZ3k6IHNjcm9sbFN0cmF0ZWd5ID8gJ3Njcm9sbCcgOiAnb2JqZWN0JyB9KTtcbiAgICB9XG5cblxuICAgIGxldCBmaXJzdEV2ZW50ID0gdHJ1ZTtcbiAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IubGlzdGVuVG8odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICgpID0+IHtcbiAgICAgIGlmIChmaXJzdEV2ZW50KSB7XG4gICAgICAgIC8vIGVsZW1lbnRSZXNpemVEZXRlY3RvciBmaXJlcyB0aGUgZXZlbnQgZGlyZWN0bHkgYWZ0ZXIgcmUtYXR0YWNoaW5nIHRoZSBsaXN0ZW5lclxuICAgICAgICAvLyAtPiBkaXNjYXJkIHRoYXQgZmlyc3QgZXZlbnQ6XG4gICAgICAgIGZpcnN0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGFueSByZXNpemUgZXZlbnQuXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ICE9PSAnd2luZG93Jykge1xuICAgICAgaWYgKEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciAmJiB0aGlzLmVsZW0pIHtcbiAgICAgICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yLnJlbW92ZUFsbExpc3RlbmVycyh0aGlzLmVsZW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVdpbmRvd1Jlc2l6ZUxpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luYWwgdGV4dCdzIHRydW5jYXRlZCB2ZXJzaW9uLiBJZiB0aGUgdGV4dCByZWFsbHkgbmVlZGVkIHRvXG4gICAqIGJlIHRydW5jYXRlZCwgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBsZW5ndGggdGhlIHRleHQgbWF5IGhhdmVcbiAgICogQHJldHVybiBzdHJpbmcgICAgICAgdGhlIHRydW5jYXRlZCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgZ2V0VHJ1bmNhdGVkVGV4dChtYXg6IG51bWJlcik6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCB8fCB0aGlzLm9yaWdpbmFsVGV4dC5sZW5ndGggPD0gbWF4KSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFRleHQ7XG4gICAgfVxuXG4gICAgY29uc3QgdHJ1bmNhdGVkVGV4dCA9IHRoaXMuZWxsaXBzaXNTdWJzdHJGbih0aGlzLm9yaWdpbmFsVGV4dCwgMCwgbWF4KTtcbiAgICBpZiAodGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID09PSAnW10nIHx8IHRoaXMub3JpZ2luYWxUZXh0LmNoYXJBdChtYXgpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIHJldHVybiB0cnVuY2F0ZWRUZXh0O1xuICAgIH1cblxuICAgIGxldCBpID0gbWF4IC0gMTtcbiAgICB3aGlsZSAoaSA+IDAgJiYgIXRydW5jYXRlZFRleHQuY2hhckF0KGkpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWxsaXBzaXNTdWJzdHJGbih0cnVuY2F0ZWRUZXh0LCAwLCBpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRydW5jYXRlZCB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5uZXIgZGl2XG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEBwYXJhbSBhZGRNb3JlTGlzdGVuZXI9ZmFsc2UgbGlzdGVuIGZvciBjbGljayBvbiB0aGUgZWxsaXBzaXNDaGFyYWN0ZXJzIGFuY2hvciB0YWcgaWYgdGhlIHRleHQgaGFzIGJlZW4gdHJ1bmNhdGVkXG4gICAqIEByZXR1cm5zIGxlbmd0aCBvZiByZW1haW5pbmcgdGV4dCAoZXhjbHVkaW5nIHRoZSBlbGxpcHNpc0NoYXJhY3RlcnMsIGlmIHRoZXkgd2VyZSBhZGRlZClcbiAgICovXG4gIHByaXZhdGUgdHJ1bmNhdGVUZXh0KG1heDogbnVtYmVyLCBhZGRNb3JlTGlzdGVuZXIgPSBmYWxzZSk6IG51bWJlciB7XG4gICAgbGV0IHRleHQgPSB0aGlzLmdldFRydW5jYXRlZFRleHQobWF4KTtcbiAgICBjb25zdCB0cnVuY2F0ZWRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICBjb25zdCB0ZXh0VHJ1bmNhdGVkID0gKHRydW5jYXRlZExlbmd0aCAhPT0gdGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoKTtcblxuICAgIGlmICh0ZXh0VHJ1bmNhdGVkICYmICF0aGlzLnNob3dNb3JlTGluaykge1xuICAgICAgdGV4dCArPSB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycztcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaW5uZXJFbGVtLCAndGV4dENvbnRlbnQnLCB0ZXh0KTtcblxuICAgIGlmICh0ZXh0VHJ1bmNhdGVkICYmIHRoaXMuc2hvd01vcmVMaW5rKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJFbGVtLCB0aGlzLm1vcmVBbmNob3IpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgbW9yZSBjbGljayBsaXN0ZW5lcjpcbiAgICBpZiAodGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKCk7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHRleHQgaGFzIGJlZW4gdHJ1bmNhdGVkLCBhZGQgYSBtb3JlIGNsaWNrIGxpc3RlbmVyOlxuICAgIGlmIChhZGRNb3JlTGlzdGVuZXIgJiYgdGV4dFRydW5jYXRlZCkge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLm1vcmVBbmNob3IsICdjbGljaycsIChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZS50YXJnZXQgfHwgKDxIVE1MRWxlbWVudD4gZS50YXJnZXQpLmNsYXNzTmFtZSAhPT0gJ25neC1lbGxpcHNpcy1tb3JlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubW9yZUNsaWNrRW1pdHRlci5lbWl0KGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydW5jYXRlZExlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IGVsbGlwc2lzIGluIHRoZSBpbm5lciBkaXYgaWYgdGhlIHRleHQgd291bGQgZXhjZWVkIHRoZSBib3VuZGFyaWVzXG4gICAqL1xuICBwdWJsaWMgYXBwbHlFbGxpcHNpcygpIHtcbiAgICAvLyBSZW1vdmUgdGhlIHJlc2l6ZSBsaXN0ZW5lciBhcyBjaGFuZ2luZyB0aGUgY29udGFpbmVkIHRleHQgd291bGQgdHJpZ2dlciBldmVudHM6XG4gICAgdGhpcy5yZW1vdmVSZXNpemVMaXN0ZW5lcigpO1xuXG4gICAgLy8gRmluZCB0aGUgYmVzdCBsZW5ndGggYnkgdHJpYWwgYW5kIGVycm9yOlxuICAgIGNvbnN0IG1heExlbmd0aCA9IEVsbGlwc2lzRGlyZWN0aXZlLm51bWVyaWNCaW5hcnlTZWFyY2godGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoLCBjdXJMZW5ndGggPT4ge1xuICAgICAgdGhpcy50cnVuY2F0ZVRleHQoY3VyTGVuZ3RoKTtcbiAgICAgIHJldHVybiAhdGhpcy5pc092ZXJmbG93aW5nO1xuICAgIH0pO1xuXG4gICAgLy8gQXBwbHkgdGhlIGJlc3QgbGVuZ3RoOlxuICAgIGNvbnN0IGZpbmFsTGVuZ3RoID0gdGhpcy50cnVuY2F0ZVRleHQobWF4TGVuZ3RoLCB0aGlzLnNob3dNb3JlTGluayk7XG5cbiAgICAvLyBSZS1hdHRhY2ggdGhlIHJlc2l6ZSBsaXN0ZW5lcjpcbiAgICB0aGlzLmFkZFJlc2l6ZUxpc3RlbmVyKCk7XG5cbiAgICAvLyBFbWl0IGNoYW5nZSBldmVudDpcbiAgICBpZiAodGhpcy5jaGFuZ2VFbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNoYW5nZUVtaXR0ZXIuZW1pdChcbiAgICAgICAgKHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCA9PT0gZmluYWxMZW5ndGgpID8gbnVsbCA6IGZpbmFsTGVuZ3RoXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHRleHQgaXMgZXhjZWVkaW5nIHRoZSBlbGVtZW50J3MgYm91bmRhcmllcyBvciBub3RcbiAgICovXG4gIHByaXZhdGUgZ2V0IGlzT3ZlcmZsb3dpbmcoKTogYm9vbGVhbiB7XG4gICAgLy8gRW5mb3JjZSBoaWRkZW4gb3ZlcmZsb3cgKHJlcXVpcmVkIHRvIGNvbXBhcmUgY2xpZW50IHdpZHRoL2hlaWdodCB3aXRoIHNjcm9sbCB3aWR0aC9oZWlnaHQpXG4gICAgY29uc3QgY3VycmVudE92ZXJmbG93ID0gdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93O1xuICAgIGlmICghY3VycmVudE92ZXJmbG93IHx8IGN1cnJlbnRPdmVyZmxvdyA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjb25zdCBpc092ZXJmbG93aW5nID0gdGhpcy5lbGVtLmNsaWVudFdpZHRoIDwgdGhpcy5lbGVtLnNjcm9sbFdpZHRoIC0gMSB8fCB0aGlzLmVsZW0uY2xpZW50SGVpZ2h0IDwgdGhpcy5lbGVtLnNjcm9sbEhlaWdodCAtIDE7XG5cbiAgICAvLyBSZXNldCBvdmVyZmxvdyB0byB0aGUgb3JpZ2luYWwgY29uZmlndXJhdGlvbjpcbiAgICB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3cgPSBjdXJyZW50T3ZlcmZsb3c7XG5cbiAgICByZXR1cm4gaXNPdmVyZmxvd2luZztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBgZWxsaXBzaXNDaGFyYWN0ZXJzYCBhcmUgdG8gYmUgd3JhcHBlZCBpbnNpZGUgYW4gYW5jaG9yIHRhZyAoaWYgdGhleSBhcmUgc2hvd24gYXQgYWxsKVxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgc2hvd01vcmVMaW5rKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5tb3JlQ2xpY2tFbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwKTtcbiAgfVxufVxuIl19