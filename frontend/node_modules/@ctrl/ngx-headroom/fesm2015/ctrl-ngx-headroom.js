import { __decorate, __param } from 'tslib';
import { DOCUMENT, CommonModule } from '@angular/common';
import { EventEmitter, Inject, Input, Output, ViewChild, HostListener, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations';

function shouldUpdate (lastKnownScrollY = 0, currentScrollY = 0, disable, pinStart, downTolerance, upTolerance, state, height) {
    const scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';
    const distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);
    // We're disabled
    if (disable) {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
        // We're at the top and not fixed yet.
    }
    else if (currentScrollY <= pinStart && state !== 'unfixed') {
        return {
            action: 'unfix',
            scrollDirection,
            distanceScrolled,
        };
        // We're unfixed and headed down. Carry on.
    }
    else if (currentScrollY <= height &&
        scrollDirection === 'down' &&
        state === 'unfixed') {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
        // We're past the header and scrolling down.
        // We transition to "unpinned" if necessary.
    }
    else if (scrollDirection === 'down' &&
        ['pinned', 'unfixed'].indexOf(state) >= 0 &&
        currentScrollY > height + pinStart &&
        distanceScrolled > downTolerance) {
        return {
            action: 'unpin',
            scrollDirection,
            distanceScrolled,
        };
        // We're scrolling up, we transition to "pinned"
    }
    else if (scrollDirection === 'up' &&
        distanceScrolled > upTolerance &&
        ['pinned', 'unfixed'].indexOf(state) < 0) {
        return {
            action: 'pin',
            scrollDirection,
            distanceScrolled,
        };
        // We're scrolling up, and inside the header.
        // We transition to pin regardless of upTolerance
    }
    else if (scrollDirection === 'up' &&
        currentScrollY <= height &&
        ['pinned', 'unfixed'].indexOf(state) < 0) {
        return {
            action: 'pin',
            scrollDirection,
            distanceScrolled,
        };
    }
    else {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
    }
}

let HeadroomComponent = class HeadroomComponent {
    constructor(document) {
        this.document = document;
        this.wrapperClassName = '';
        this.innerClassName = '';
        this.innerStyle = {
            top: '0',
            left: '0',
            right: '0',
            zIndex: '1',
            position: 'relative',
        };
        /**
         * pass styles for the wrapper div
         * (this maintains the components vertical space at the top of the page)
         */
        this.wrapperStyle = {};
        /** disable pinning and unpinning */
        this.disable = false;
        /** scroll tolerance in px when scrolling up before component is pinned */
        this.upTolerance = 5;
        /** scroll tolerance in px when scrolling down before component is pinned */
        this.downTolerance = 0;
        /**
         * height in px where the header should start and stop pinning.
         * Useful when you have another element above Headroom
         */
        this.pinStart = 0;
        this.calcHeightOnResize = true;
        /** Duration of animation in ms */
        this.duration = 200;
        /** Easing of animation */
        this.easing = 'ease-in-out';
        this.pin = new EventEmitter();
        this.unpin = new EventEmitter();
        this.unfix = new EventEmitter();
        this.wrapperHeight = 0;
        this.currentScrollY = 0;
        this.lastKnownScrollY = 0;
        this.scrolled = false;
        this.resizeTicking = false;
        this.state = 'unfixed';
        this.translateY = '0px';
        this.scrollTicking = false;
    }
    scroll() {
        this.handleScroll();
    }
    resize() {
        this.handleResize();
    }
    ngOnInit() {
        this.innerStyle.transform = `translateY(${this.translateY})`;
        if (this.disable === true) {
            this.handleUnfix();
        }
    }
    getParent() {
        if (this.parent) {
            return this.parent();
        }
        if (this.document.documentElement && this.document.documentElement.scrollTop) {
            return this.document.documentElement;
        }
        if (this.document.body && this.document.body.scrollTop) {
            return this.document.body;
        }
        if (this.document.body && this.document.body.parentNode.scrollTop) {
            return this.document.body.parentNode;
        }
        return this.document;
    }
    ngAfterContentInit() {
        this.setHeightOffset();
        this.wrapperHeight = this.height ? this.height : null;
    }
    setHeightOffset() {
        this.height = null;
        setTimeout(() => {
            this.height = this.inner.nativeElement.offsetHeight;
            this.resizeTicking = false;
        }, 0);
    }
    getScrollY() {
        if (this.getParent().pageYOffset !== undefined) {
            return this.getParent().pageYOffset;
        }
        return this.getParent().scrollTop || 0;
    }
    getViewportHeight() {
        return (this.getParent().innerHeight ||
            this.document.documentElement.clientHeight ||
            this.document.body.clientHeight);
    }
    getDocumentHeight() {
        const body = this.document.body;
        const documentElement = this.document.documentElement;
        return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
    }
    getElementPhysicalHeight(elm) {
        return Math.max(elm.offsetHeight, elm.clientHeight);
    }
    getElementHeight(elm) {
        return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
    }
    getScrollerPhysicalHeight() {
        const parent = this.getParent();
        return parent === this.getParent() || parent === this.document.body
            ? this.getViewportHeight()
            : this.getElementPhysicalHeight(parent);
    }
    getScrollerHeight() {
        const parent = this.getParent();
        return parent === this.getParent() || parent === this.document.body
            ? this.getDocumentHeight()
            : this.getElementHeight(parent);
    }
    isOutOfBound(currentScrollY) {
        const pastTop = currentScrollY < 0;
        const scrollerPhysicalHeight = this.getScrollerPhysicalHeight();
        const scrollerHeight = this.getScrollerHeight();
        const pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;
        return pastTop || pastBottom;
    }
    handleScroll() {
        if (this.disable) {
            return;
        }
        if (!this.scrollTicking) {
            this.scrollTicking = true;
            this.update();
        }
    }
    handleResize() {
        if (this.disable || !this.calcHeightOnResize) {
            return;
        }
        if (!this.resizeTicking) {
            this.resizeTicking = true;
            this.setHeightOffset();
        }
    }
    handleUnpin() {
        this.unpin.emit();
        this.state = 'unpinned';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    handlePin() {
        this.pin.emit();
        this.state = 'pinned';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    handleUnfix() {
        this.unfix.emit();
        this.state = 'unfixed';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    update() {
        this.currentScrollY = this.getScrollY();
        if (!this.isOutOfBound(this.currentScrollY)) {
            const { action } = shouldUpdate(this.lastKnownScrollY, this.currentScrollY, this.disable, this.pinStart, this.downTolerance, this.upTolerance, this.state, this.height);
            if (action === 'pin') {
                this.handlePin();
            }
            else if (action === 'unpin') {
                this.handleUnpin();
            }
            else if (action === 'unfix') {
                this.handleUnfix();
            }
        }
        this.lastKnownScrollY = this.currentScrollY;
        this.scrollTicking = false;
    }
};
HeadroomComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input()
], HeadroomComponent.prototype, "wrapperClassName", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "innerClassName", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "innerStyle", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "wrapperStyle", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "disable", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "upTolerance", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "downTolerance", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "pinStart", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "calcHeightOnResize", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "duration", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "easing", void 0);
__decorate([
    Output()
], HeadroomComponent.prototype, "pin", void 0);
__decorate([
    Output()
], HeadroomComponent.prototype, "unpin", void 0);
__decorate([
    Output()
], HeadroomComponent.prototype, "unfix", void 0);
__decorate([
    ViewChild('ref', { static: true })
], HeadroomComponent.prototype, "inner", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "parent", void 0);
__decorate([
    Input(), HostListener('window:scroll')
], HeadroomComponent.prototype, "scroll", null);
__decorate([
    Input(),
    HostListener('window:resize')
], HeadroomComponent.prototype, "resize", null);
HeadroomComponent = __decorate([
    Component({
        selector: 'ngx-headroom',
        template: `
  <div [ngStyle]="wrapperStyle" class="headroom-wrapper {{ wrapperClassName }}"
    [style.height.px]="wrapperHeight">
    <div #ref
      [@headroom]="{
        value: state,
        params: {
          duration: duration,
          easing: easing
        }
      }"
      [ngStyle]="innerStyle"
      [class]="innerClassName"
      [class.headroom]="true"
      [class.headroom--unfixed]="state === 'unfixed'"
      [class.headroom--unpinned]="state === 'unpinned'"
      [class.headroom--pinned]="state === 'pinned'"
      [class.headroom--unfixed]="state === 'unfixed'">
      <ng-content></ng-content>
    </div>
  </div>
  `,
        animations: [
            trigger('headroom', [
                state('unfixed', style({
                    transform: 'translateY(0)',
                })),
                state('unpinned', style({
                    transform: 'translateY(-100%)',
                })),
                state('pinned', style({
                    transform: 'translateY(0px)',
                })),
                transition('unpinned <=> pinned', animate('{{ duration }}ms {{ easing }}')),
            ]),
        ],
        preserveWhitespaces: false,
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __param(0, Inject(DOCUMENT))
], HeadroomComponent);

let HeadroomModule = class HeadroomModule {
};
HeadroomModule = __decorate([
    NgModule({
        imports: [CommonModule],
        exports: [HeadroomComponent],
        declarations: [HeadroomComponent],
    })
], HeadroomModule);

/**
 * Generated bundle index. Do not edit.
 */

export { HeadroomComponent, HeadroomModule };
//# sourceMappingURL=ctrl-ngx-headroom.js.map
