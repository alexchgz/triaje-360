import { __decorate, __param } from 'tslib';
import { DOCUMENT, CommonModule } from '@angular/common';
import { EventEmitter, Inject, Input, Output, ViewChild, HostListener, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations';

function shouldUpdate (lastKnownScrollY, currentScrollY, disable, pinStart, downTolerance, upTolerance, state, height) {
    if (lastKnownScrollY === void 0) { lastKnownScrollY = 0; }
    if (currentScrollY === void 0) { currentScrollY = 0; }
    var scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';
    var distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);
    // We're disabled
    if (disable) {
        return {
            action: 'none',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're at the top and not fixed yet.
    }
    else if (currentScrollY <= pinStart && state !== 'unfixed') {
        return {
            action: 'unfix',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're unfixed and headed down. Carry on.
    }
    else if (currentScrollY <= height &&
        scrollDirection === 'down' &&
        state === 'unfixed') {
        return {
            action: 'none',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're past the header and scrolling down.
        // We transition to "unpinned" if necessary.
    }
    else if (scrollDirection === 'down' &&
        ['pinned', 'unfixed'].indexOf(state) >= 0 &&
        currentScrollY > height + pinStart &&
        distanceScrolled > downTolerance) {
        return {
            action: 'unpin',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're scrolling up, we transition to "pinned"
    }
    else if (scrollDirection === 'up' &&
        distanceScrolled > upTolerance &&
        ['pinned', 'unfixed'].indexOf(state) < 0) {
        return {
            action: 'pin',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
        // We're scrolling up, and inside the header.
        // We transition to pin regardless of upTolerance
    }
    else if (scrollDirection === 'up' &&
        currentScrollY <= height &&
        ['pinned', 'unfixed'].indexOf(state) < 0) {
        return {
            action: 'pin',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
    }
    else {
        return {
            action: 'none',
            scrollDirection: scrollDirection,
            distanceScrolled: distanceScrolled,
        };
    }
}

var HeadroomComponent = /** @class */ (function () {
    function HeadroomComponent(document) {
        this.document = document;
        this.wrapperClassName = '';
        this.innerClassName = '';
        this.innerStyle = {
            top: '0',
            left: '0',
            right: '0',
            zIndex: '1',
            position: 'relative',
        };
        /**
         * pass styles for the wrapper div
         * (this maintains the components vertical space at the top of the page)
         */
        this.wrapperStyle = {};
        /** disable pinning and unpinning */
        this.disable = false;
        /** scroll tolerance in px when scrolling up before component is pinned */
        this.upTolerance = 5;
        /** scroll tolerance in px when scrolling down before component is pinned */
        this.downTolerance = 0;
        /**
         * height in px where the header should start and stop pinning.
         * Useful when you have another element above Headroom
         */
        this.pinStart = 0;
        this.calcHeightOnResize = true;
        /** Duration of animation in ms */
        this.duration = 200;
        /** Easing of animation */
        this.easing = 'ease-in-out';
        this.pin = new EventEmitter();
        this.unpin = new EventEmitter();
        this.unfix = new EventEmitter();
        this.wrapperHeight = 0;
        this.currentScrollY = 0;
        this.lastKnownScrollY = 0;
        this.scrolled = false;
        this.resizeTicking = false;
        this.state = 'unfixed';
        this.translateY = '0px';
        this.scrollTicking = false;
    }
    HeadroomComponent.prototype.scroll = function () {
        this.handleScroll();
    };
    HeadroomComponent.prototype.resize = function () {
        this.handleResize();
    };
    HeadroomComponent.prototype.ngOnInit = function () {
        this.innerStyle.transform = "translateY(" + this.translateY + ")";
        if (this.disable === true) {
            this.handleUnfix();
        }
    };
    HeadroomComponent.prototype.getParent = function () {
        if (this.parent) {
            return this.parent();
        }
        if (this.document.documentElement && this.document.documentElement.scrollTop) {
            return this.document.documentElement;
        }
        if (this.document.body && this.document.body.scrollTop) {
            return this.document.body;
        }
        if (this.document.body && this.document.body.parentNode.scrollTop) {
            return this.document.body.parentNode;
        }
        return this.document;
    };
    HeadroomComponent.prototype.ngAfterContentInit = function () {
        this.setHeightOffset();
        this.wrapperHeight = this.height ? this.height : null;
    };
    HeadroomComponent.prototype.setHeightOffset = function () {
        var _this = this;
        this.height = null;
        setTimeout(function () {
            _this.height = _this.inner.nativeElement.offsetHeight;
            _this.resizeTicking = false;
        }, 0);
    };
    HeadroomComponent.prototype.getScrollY = function () {
        if (this.getParent().pageYOffset !== undefined) {
            return this.getParent().pageYOffset;
        }
        return this.getParent().scrollTop || 0;
    };
    HeadroomComponent.prototype.getViewportHeight = function () {
        return (this.getParent().innerHeight ||
            this.document.documentElement.clientHeight ||
            this.document.body.clientHeight);
    };
    HeadroomComponent.prototype.getDocumentHeight = function () {
        var body = this.document.body;
        var documentElement = this.document.documentElement;
        return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
    };
    HeadroomComponent.prototype.getElementPhysicalHeight = function (elm) {
        return Math.max(elm.offsetHeight, elm.clientHeight);
    };
    HeadroomComponent.prototype.getElementHeight = function (elm) {
        return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
    };
    HeadroomComponent.prototype.getScrollerPhysicalHeight = function () {
        var parent = this.getParent();
        return parent === this.getParent() || parent === this.document.body
            ? this.getViewportHeight()
            : this.getElementPhysicalHeight(parent);
    };
    HeadroomComponent.prototype.getScrollerHeight = function () {
        var parent = this.getParent();
        return parent === this.getParent() || parent === this.document.body
            ? this.getDocumentHeight()
            : this.getElementHeight(parent);
    };
    HeadroomComponent.prototype.isOutOfBound = function (currentScrollY) {
        var pastTop = currentScrollY < 0;
        var scrollerPhysicalHeight = this.getScrollerPhysicalHeight();
        var scrollerHeight = this.getScrollerHeight();
        var pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;
        return pastTop || pastBottom;
    };
    HeadroomComponent.prototype.handleScroll = function () {
        if (this.disable) {
            return;
        }
        if (!this.scrollTicking) {
            this.scrollTicking = true;
            this.update();
        }
    };
    HeadroomComponent.prototype.handleResize = function () {
        if (this.disable || !this.calcHeightOnResize) {
            return;
        }
        if (!this.resizeTicking) {
            this.resizeTicking = true;
            this.setHeightOffset();
        }
    };
    HeadroomComponent.prototype.handleUnpin = function () {
        this.unpin.emit();
        this.state = 'unpinned';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    };
    HeadroomComponent.prototype.handlePin = function () {
        this.pin.emit();
        this.state = 'pinned';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    };
    HeadroomComponent.prototype.handleUnfix = function () {
        this.unfix.emit();
        this.state = 'unfixed';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    };
    HeadroomComponent.prototype.update = function () {
        this.currentScrollY = this.getScrollY();
        if (!this.isOutOfBound(this.currentScrollY)) {
            var action = shouldUpdate(this.lastKnownScrollY, this.currentScrollY, this.disable, this.pinStart, this.downTolerance, this.upTolerance, this.state, this.height).action;
            if (action === 'pin') {
                this.handlePin();
            }
            else if (action === 'unpin') {
                this.handleUnpin();
            }
            else if (action === 'unfix') {
                this.handleUnfix();
            }
        }
        this.lastKnownScrollY = this.currentScrollY;
        this.scrollTicking = false;
    };
    HeadroomComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "wrapperClassName", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "innerClassName", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "innerStyle", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "wrapperStyle", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "disable", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "upTolerance", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "downTolerance", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "pinStart", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "calcHeightOnResize", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "duration", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "easing", void 0);
    __decorate([
        Output()
    ], HeadroomComponent.prototype, "pin", void 0);
    __decorate([
        Output()
    ], HeadroomComponent.prototype, "unpin", void 0);
    __decorate([
        Output()
    ], HeadroomComponent.prototype, "unfix", void 0);
    __decorate([
        ViewChild('ref', { static: true })
    ], HeadroomComponent.prototype, "inner", void 0);
    __decorate([
        Input()
    ], HeadroomComponent.prototype, "parent", void 0);
    __decorate([
        Input(), HostListener('window:scroll')
    ], HeadroomComponent.prototype, "scroll", null);
    __decorate([
        Input(),
        HostListener('window:resize')
    ], HeadroomComponent.prototype, "resize", null);
    HeadroomComponent = __decorate([
        Component({
            selector: 'ngx-headroom',
            template: "\n  <div [ngStyle]=\"wrapperStyle\" class=\"headroom-wrapper {{ wrapperClassName }}\"\n    [style.height.px]=\"wrapperHeight\">\n    <div #ref\n      [@headroom]=\"{\n        value: state,\n        params: {\n          duration: duration,\n          easing: easing\n        }\n      }\"\n      [ngStyle]=\"innerStyle\"\n      [class]=\"innerClassName\"\n      [class.headroom]=\"true\"\n      [class.headroom--unfixed]=\"state === 'unfixed'\"\n      [class.headroom--unpinned]=\"state === 'unpinned'\"\n      [class.headroom--pinned]=\"state === 'pinned'\"\n      [class.headroom--unfixed]=\"state === 'unfixed'\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n  ",
            animations: [
                trigger('headroom', [
                    state('unfixed', style({
                        transform: 'translateY(0)',
                    })),
                    state('unpinned', style({
                        transform: 'translateY(-100%)',
                    })),
                    state('pinned', style({
                        transform: 'translateY(0px)',
                    })),
                    transition('unpinned <=> pinned', animate('{{ duration }}ms {{ easing }}')),
                ]),
            ],
            preserveWhitespaces: false,
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __param(0, Inject(DOCUMENT))
    ], HeadroomComponent);
    return HeadroomComponent;
}());

var HeadroomModule = /** @class */ (function () {
    function HeadroomModule() {
    }
    HeadroomModule = __decorate([
        NgModule({
            imports: [CommonModule],
            exports: [HeadroomComponent],
            declarations: [HeadroomComponent],
        })
    ], HeadroomModule);
    return HeadroomModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { HeadroomComponent, HeadroomModule };
//# sourceMappingURL=ctrl-ngx-headroom.js.map
