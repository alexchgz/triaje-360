import { __decorate, __param } from 'tslib';
import { DOCUMENT, CommonModule } from '@angular/common';
import { EventEmitter, Inject, Input, Output, ViewChild, HostListener, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["ref"];
const _c1 = function (a0, a1) { return { duration: a0, easing: a1 }; };
const _c2 = function (a0, a1) { return { value: a0, params: a1 }; };
const _c3 = ["*"];
function shouldUpdate (lastKnownScrollY = 0, currentScrollY = 0, disable, pinStart, downTolerance, upTolerance, state, height) {
    const scrollDirection = currentScrollY >= lastKnownScrollY ? 'down' : 'up';
    const distanceScrolled = Math.abs(currentScrollY - lastKnownScrollY);
    // We're disabled
    if (disable) {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
        // We're at the top and not fixed yet.
    }
    else if (currentScrollY <= pinStart && state !== 'unfixed') {
        return {
            action: 'unfix',
            scrollDirection,
            distanceScrolled,
        };
        // We're unfixed and headed down. Carry on.
    }
    else if (currentScrollY <= height &&
        scrollDirection === 'down' &&
        state === 'unfixed') {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
        // We're past the header and scrolling down.
        // We transition to "unpinned" if necessary.
    }
    else if (scrollDirection === 'down' &&
        ['pinned', 'unfixed'].indexOf(state) >= 0 &&
        currentScrollY > height + pinStart &&
        distanceScrolled > downTolerance) {
        return {
            action: 'unpin',
            scrollDirection,
            distanceScrolled,
        };
        // We're scrolling up, we transition to "pinned"
    }
    else if (scrollDirection === 'up' &&
        distanceScrolled > upTolerance &&
        ['pinned', 'unfixed'].indexOf(state) < 0) {
        return {
            action: 'pin',
            scrollDirection,
            distanceScrolled,
        };
        // We're scrolling up, and inside the header.
        // We transition to pin regardless of upTolerance
    }
    else if (scrollDirection === 'up' &&
        currentScrollY <= height &&
        ['pinned', 'unfixed'].indexOf(state) < 0) {
        return {
            action: 'pin',
            scrollDirection,
            distanceScrolled,
        };
    }
    else {
        return {
            action: 'none',
            scrollDirection,
            distanceScrolled,
        };
    }
}

let HeadroomComponent = class HeadroomComponent {
    constructor(document) {
        this.document = document;
        this.wrapperClassName = '';
        this.innerClassName = '';
        this.innerStyle = {
            top: '0',
            left: '0',
            right: '0',
            zIndex: '1',
            position: 'relative',
        };
        /**
         * pass styles for the wrapper div
         * (this maintains the components vertical space at the top of the page)
         */
        this.wrapperStyle = {};
        /** disable pinning and unpinning */
        this.disable = false;
        /** scroll tolerance in px when scrolling up before component is pinned */
        this.upTolerance = 5;
        /** scroll tolerance in px when scrolling down before component is pinned */
        this.downTolerance = 0;
        /**
         * height in px where the header should start and stop pinning.
         * Useful when you have another element above Headroom
         */
        this.pinStart = 0;
        this.calcHeightOnResize = true;
        /** Duration of animation in ms */
        this.duration = 200;
        /** Easing of animation */
        this.easing = 'ease-in-out';
        this.pin = new EventEmitter();
        this.unpin = new EventEmitter();
        this.unfix = new EventEmitter();
        this.wrapperHeight = 0;
        this.currentScrollY = 0;
        this.lastKnownScrollY = 0;
        this.scrolled = false;
        this.resizeTicking = false;
        this.state = 'unfixed';
        this.translateY = '0px';
        this.scrollTicking = false;
    }
    scroll() {
        this.handleScroll();
    }
    resize() {
        this.handleResize();
    }
    ngOnInit() {
        this.innerStyle.transform = `translateY(${this.translateY})`;
        if (this.disable === true) {
            this.handleUnfix();
        }
    }
    getParent() {
        if (this.parent) {
            return this.parent();
        }
        if (this.document.documentElement && this.document.documentElement.scrollTop) {
            return this.document.documentElement;
        }
        if (this.document.body && this.document.body.scrollTop) {
            return this.document.body;
        }
        if (this.document.body && this.document.body.parentNode.scrollTop) {
            return this.document.body.parentNode;
        }
        return this.document;
    }
    ngAfterContentInit() {
        this.setHeightOffset();
        this.wrapperHeight = this.height ? this.height : null;
    }
    setHeightOffset() {
        this.height = null;
        setTimeout(() => {
            this.height = this.inner.nativeElement.offsetHeight;
            this.resizeTicking = false;
        }, 0);
    }
    getScrollY() {
        if (this.getParent().pageYOffset !== undefined) {
            return this.getParent().pageYOffset;
        }
        return this.getParent().scrollTop || 0;
    }
    getViewportHeight() {
        return (this.getParent().innerHeight ||
            this.document.documentElement.clientHeight ||
            this.document.body.clientHeight);
    }
    getDocumentHeight() {
        const body = this.document.body;
        const documentElement = this.document.documentElement;
        return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
    }
    getElementPhysicalHeight(elm) {
        return Math.max(elm.offsetHeight, elm.clientHeight);
    }
    getElementHeight(elm) {
        return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
    }
    getScrollerPhysicalHeight() {
        const parent = this.getParent();
        return parent === this.getParent() || parent === this.document.body
            ? this.getViewportHeight()
            : this.getElementPhysicalHeight(parent);
    }
    getScrollerHeight() {
        const parent = this.getParent();
        return parent === this.getParent() || parent === this.document.body
            ? this.getDocumentHeight()
            : this.getElementHeight(parent);
    }
    isOutOfBound(currentScrollY) {
        const pastTop = currentScrollY < 0;
        const scrollerPhysicalHeight = this.getScrollerPhysicalHeight();
        const scrollerHeight = this.getScrollerHeight();
        const pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;
        return pastTop || pastBottom;
    }
    handleScroll() {
        if (this.disable) {
            return;
        }
        if (!this.scrollTicking) {
            this.scrollTicking = true;
            this.update();
        }
    }
    handleResize() {
        if (this.disable || !this.calcHeightOnResize) {
            return;
        }
        if (!this.resizeTicking) {
            this.resizeTicking = true;
            this.setHeightOffset();
        }
    }
    handleUnpin() {
        this.unpin.emit();
        this.state = 'unpinned';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    handlePin() {
        this.pin.emit();
        this.state = 'pinned';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    handleUnfix() {
        this.unfix.emit();
        this.state = 'unfixed';
        this.innerStyle.position =
            this.disable || this.state === 'unfixed' ? 'relative' : 'fixed';
    }
    update() {
        this.currentScrollY = this.getScrollY();
        if (!this.isOutOfBound(this.currentScrollY)) {
            const { action } = shouldUpdate(this.lastKnownScrollY, this.currentScrollY, this.disable, this.pinStart, this.downTolerance, this.upTolerance, this.state, this.height);
            if (action === 'pin') {
                this.handlePin();
            }
            else if (action === 'unpin') {
                this.handleUnpin();
            }
            else if (action === 'unfix') {
                this.handleUnfix();
            }
        }
        this.lastKnownScrollY = this.currentScrollY;
        this.scrollTicking = false;
    }
};
HeadroomComponent.ɵfac = function HeadroomComponent_Factory(t) { return new (t || HeadroomComponent)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT)); };
HeadroomComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeadroomComponent, selectors: [["ngx-headroom"]], viewQuery: function HeadroomComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inner = _t.first);
    } }, hostBindings: function HeadroomComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function HeadroomComponent_scroll_HostBindingHandler() { return ctx.scroll(); }, false, ɵngcc0.ɵɵresolveWindow)("resize", function HeadroomComponent_resize_HostBindingHandler() { return ctx.resize(); }, false, ɵngcc0.ɵɵresolveWindow);
    } }, inputs: { wrapperClassName: "wrapperClassName", innerClassName: "innerClassName", innerStyle: "innerStyle", wrapperStyle: "wrapperStyle", disable: "disable", upTolerance: "upTolerance", downTolerance: "downTolerance", pinStart: "pinStart", calcHeightOnResize: "calcHeightOnResize", duration: "duration", easing: "easing", scroll: "scroll", resize: "resize", parent: "parent" }, outputs: { pin: "pin", unpin: "unpin", unfix: "unfix" }, ngContentSelectors: _c3, decls: 4, vars: 26, consts: [[3, "ngStyle"], ["ref", ""]], template: function HeadroomComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 0, 1);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMapInterpolate1("headroom-wrapper ", ctx.wrapperClassName, "");
        ɵngcc0.ɵɵstyleProp("height", ctx.wrapperHeight, "px");
        ɵngcc0.ɵɵproperty("ngStyle", ctx.wrapperStyle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMap(ctx.innerClassName);
        ɵngcc0.ɵɵclassProp("headroom", true)("headroom--unfixed", ctx.state === "unfixed")("headroom--unpinned", ctx.state === "unpinned")("headroom--pinned", ctx.state === "pinned")("headroom--unfixed", ctx.state === "unfixed");
        ɵngcc0.ɵɵproperty("@headroom", ɵngcc0.ɵɵpureFunction2(23, _c2, ctx.state, ɵngcc0.ɵɵpureFunction2(20, _c1, ctx.duration, ctx.easing)))("ngStyle", ctx.innerStyle);
    } }, directives: [ɵngcc1.NgStyle], encapsulation: 2, data: { animation: [
            trigger('headroom', [
                state('unfixed', style({
                    transform: 'translateY(0)'
                })),
                state('unpinned', style({
                    transform: 'translateY(-100%)'
                })),
                state('pinned', style({
                    transform: 'translateY(0px)'
                })),
                transition('unpinned <=> pinned', animate('{{ duration }}ms {{ easing }}')),
            ]),
        ] }, changeDetection: 0 });
HeadroomComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input()
], HeadroomComponent.prototype, "wrapperClassName", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "innerClassName", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "innerStyle", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "wrapperStyle", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "disable", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "upTolerance", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "downTolerance", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "pinStart", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "calcHeightOnResize", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "duration", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "easing", void 0);
__decorate([
    Output()
], HeadroomComponent.prototype, "pin", void 0);
__decorate([
    Output()
], HeadroomComponent.prototype, "unpin", void 0);
__decorate([
    Output()
], HeadroomComponent.prototype, "unfix", void 0);
__decorate([
    ViewChild('ref', { static: true })
], HeadroomComponent.prototype, "inner", void 0);
__decorate([
    Input()
], HeadroomComponent.prototype, "parent", void 0);
__decorate([
    Input(), HostListener('window:scroll')
], HeadroomComponent.prototype, "scroll", null);
__decorate([
    Input(),
    HostListener('window:resize')
], HeadroomComponent.prototype, "resize", null);
HeadroomComponent = __decorate([ __param(0, Inject(DOCUMENT))
], HeadroomComponent);

let HeadroomModule = class HeadroomModule {
};
HeadroomModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HeadroomModule });
HeadroomModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HeadroomModule_Factory(t) { return new (t || HeadroomModule)(); }, imports: [[CommonModule]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeadroomComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-headroom',
                template: `
  <div [ngStyle]="wrapperStyle" class="headroom-wrapper {{ wrapperClassName }}"
    [style.height.px]="wrapperHeight">
    <div #ref
      [@headroom]="{
        value: state,
        params: {
          duration: duration,
          easing: easing
        }
      }"
      [ngStyle]="innerStyle"
      [class]="innerClassName"
      [class.headroom]="true"
      [class.headroom--unfixed]="state === 'unfixed'"
      [class.headroom--unpinned]="state === 'unpinned'"
      [class.headroom--pinned]="state === 'pinned'"
      [class.headroom--unfixed]="state === 'unfixed'">
      <ng-content></ng-content>
    </div>
  </div>
  `,
                animations: [
                    trigger('headroom', [
                        state('unfixed', style({
                            transform: 'translateY(0)'
                        })),
                        state('unpinned', style({
                            transform: 'translateY(-100%)'
                        })),
                        state('pinned', style({
                            transform: 'translateY(0px)'
                        })),
                        transition('unpinned <=> pinned', animate('{{ duration }}ms {{ easing }}')),
                    ]),
                ],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, { wrapperClassName: [{
            type: Input
        }], innerClassName: [{
            type: Input
        }], innerStyle: [{
            type: Input
        }], wrapperStyle: [{
            type: Input
        }], disable: [{
            type: Input
        }], upTolerance: [{
            type: Input
        }], downTolerance: [{
            type: Input
        }], pinStart: [{
            type: Input
        }], calcHeightOnResize: [{
            type: Input
        }], duration: [{
            type: Input
        }], easing: [{
            type: Input
        }], pin: [{
            type: Output
        }], unpin: [{
            type: Output
        }], unfix: [{
            type: Output
        }], scroll: [{
            type: Input
        }, {
            type: HostListener,
            args: ['window:scroll']
        }], resize: [{
            type: Input
        }, {
            type: HostListener,
            args: ['window:resize']
        }], inner: [{
            type: ViewChild,
            args: ['ref', { static: true }]
        }], parent: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HeadroomModule, { declarations: function () { return [HeadroomComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [HeadroomComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeadroomModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                exports: [HeadroomComponent],
                declarations: [HeadroomComponent]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { HeadroomComponent, HeadroomModule };

//# sourceMappingURL=ctrl-ngx-headroom.js.map